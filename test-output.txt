{
    "Type": "AWS::Lambda::Function",
    "Properties": {
        "Code": {
            "ZipFile": "import os\\nimport boto3\\nimport string\\nimport random\\nimport json\\nimport time\\ncwlogs = boto3.client(\\'logs\\')\\ndef createLogGroup(logGroupName):\\n\\tcreateLogGroupResponse = cwlogs.create_log_group(\\n\\t\\tlogGroupName=logGroupName,\\n\\t\\ttags={\\n\\t\\t\\t\\\"Owner\\\": \\\"TrendMicro\\\",\\n\\t\\t\\t\\\"Product\\\": \\\"CloudOneApplicationSecurity\\\",\\n\\t\\t\\t\\\"Name\\\": logGroupName\\n\\t\\t}\\n\\t)\\n\\tprint(\\\"createLogGroupResponse - \\\" + str(createLogGroupResponse))\\ndef ifLogGroupExists(logGroupName):\\n\\tlistLogGroupsResponse = cwlogs.describe_log_groups()\\n\\tfor logGroup in listLogGroupsResponse[\\\"logGroups\\\"]:\\n\\t\\tif logGroupName in logGroup[\\\"logGroupName\\\"]:\\n\\t\\t\\treturn True\\n\\treturn False\\ndef createLogStream(logGroupName, logStreamName):\\n\\tcreateLogStreamResponse = cwlogs.create_log_stream(\\n\\t\\tlogGroupName=logGroupName,\\n\\t\\tlogStreamName=logStreamName\\n\\t)\\n\\tprint(\\\"createLogStreamResponse - \\\" + str(createLogStreamResponse))\\n\\tif createLogStreamResponse[\\\"ResponseMetadata\\\"][\\\"HTTPStatusCode\\\"] == 200:\\n\\t\\treturn logStreamName\\n\\treturn \\\"\\\"\\ndef putLogEvents(logGroupName, logStreamName, logEvent, nextSequenceToken=None):\\n\\tif nextSequenceToken:\\n\\t\\tputLogEventsResponse = cwlogs.put_log_events(\\n\\t\\t\\tlogGroupName=logGroupName,\\n\\t\\t\\tlogStreamName=logStreamName,\\n\\t\\t\\tlogEvents=logEvent,\\n\\t\\t\\tsequenceToken=nextSequenceToken\\n\\t\\t)\\n\\telse:\\n\\t\\tputLogEventsResponse = cwlogs.put_log_events(\\n\\t\\t\\tlogGroupName=logGroupName,\\n\\t\\t\\tlogStreamName=logStreamName,\\n\\t\\t\\tlogEvents=logEvent\\n\\t\\t)\\n\\tprint(\\\"putLogEventsResponse - \\\" + str(putLogEventsResponse))\\n\\tif \\\"rejectedLogEventsInfo\\\" not in putLogEventsResponse:\\n\\t\\treturn putLogEventsResponse[\\\"nextSequenceToken\\\"]\\n\\treturn None\\ndef lambda_handler(event, context):\\n\\tnextSequenceToken = None\\n\\tlogGroupName = str(os.environ.get(\\\"CloudWatchLogGroupName\\\"))\\n\\tlogStreamNamePrefix = str(os.environ.get(\\\"CloudWatchLogStreamNamePrefix\\\"))\\n\\tnonce = \\'\\'.join(random.choices(\\n\\t\\tstring.ascii_letters + string.digits, k=8)).upper()\\n\\tlogEvents = json.loads(event[\\\"Records\\\"][0][\\\"Sns\\\"][\\\"Message\\\"])\\n\\tif len(logEvents) > 0:\\n\\t\\tif ifLogGroupExists(logGroupName):\\n\\t\\t\\tlogStreamName = createLogStream(\\n\\t\\t\\t\\tlogGroupName, logStreamNamePrefix + \\\"-\\\" + nonce)\\n\\t\\telse:\\n\\t\\t\\tcreateLogGroup(logGroupName)\\n\\t\\t\\tlogStreamName = createLogStream(\\n\\t\\t\\t\\tlogGroupName, logStreamNamePrefix + \\\"-\\\" + nonce)\\n\\t\\tprint(str(logGroupName) + \\\" - \\\" + str(logStreamName))\\n\\t\\tfor message in logEvents:\\n\\t\\t\\tepoch_time = int(round(time.time() * 1000))\\n\\t\\t\\tlogEvent = []\\n\\t\\t\\tlogEvent.append({\\\"timestamp\\\": epoch_time, \\\"message\\\": str(message)})\\n\\t\\t\\tnextSequenceToken = putLogEvents(\\n\\t\\t\\t\\tlogGroupName, logStreamName, logEvent, nextSequenceToken)\\n\\t\\t\\tif nextSequenceToken == None:\\n\\t\\t\\t\\treturn False"
        },
        "Role": {
            "Ref": "AWS::NoValue"
        },
        "Runtime": "python3.8"
    }
}